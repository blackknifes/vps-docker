{"version":3,"file":"main.js","mappings":"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B,sGAAsC;AAC3D,aAAa,mBAAO,CAAC,8DAAc;;AAEnC;AACA;AACA;AACA;AACA,IAAI;AACJ,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mFAAmF,IAAI;AACvF,+EAA+E,IAAI;AACnF,yCAAyC,IAAI;AAC7C,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,4BAA4B,KAAK;AACjC,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,kCAAkC,aAAa;AACzG;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,aAAa,UAAU,YAAY;AACtF;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;AC1OY;;AAEZ,UAAU,8FAAoC;AAC9C;AACA,UAAU,mBAAO,CAAC,wDAAQ;AAC1B,YAAY,mBAAO,CAAC,kEAAa;AACjC;;;;;;;;;;;;ACNY;;AAEZ,UAAU,6FAAmC;AAC7C,WAAW,mBAAO,CAAC,sDAAO;AAC1B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8DAAW;AACjC,eAAe,mBAAO,CAAC,8DAAW;;AAElC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtCY;;AAEZ,UAAU,8FAAoC;AAC9C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,gCAAa;AAChC,cAAc,mBAAO,CAAC,8DAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACpEY;;AAEZ,QAAQ,6BAA6B,EAAE,mBAAO,CAAC,0DAAQ;AACvD,QAAQ,6BAA6B,EAAE,mBAAO,CAAC,0DAAQ;AACvD,QAAQ,mCAAmC,EAAE,mBAAO,CAAC,gEAAW;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBY;;AAEZ,UAAU,8FAAoC;AAC9C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,gCAAa;AAChC,cAAc,mBAAO,CAAC,8DAAW;AACjC,mBAAmB,0GAAoC;AACvD,QAAQ,eAAe,EAAE,mBAAO,CAAC,8DAAc;;AAE/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC/DY;;AAEZ,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,gCAAa;AAChC,mBAAmB,0GAAoC;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AClGY;;AAEZ,WAAW,mBAAO,CAAC,gCAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC9BY;;AAEZ,UAAU,8FAAoC;AAC9C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,sDAAO;AAC1B,gBAAgB,mBAAO,CAAC,8DAAW;AACnC;AACA;;AAEA,sBAAsB,mBAAO,CAAC,4EAAiB;AAC/C;AACA;;AAEA,qBAAqB,mBAAO,CAAC,0EAAgB;AAC7C;AACA;;AAEA,mBAAmB,0GAAoC;;AAEvD,QAAQ,eAAe,EAAE,mBAAO,CAAC,8DAAc;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACjFY;AACZ;AACA;AACA,UAAU,8FAAoC;AAC9C,WAAW,mBAAO,CAAC,gCAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,sBAAsB;AA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;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;AC1EY;;AAEZ,UAAU,8FAAoC;AAC9C,WAAW,mBAAO,CAAC,gCAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8DAAW;AACjC,mBAAmB,0GAAoC;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACvCY;AACZ,UAAU,6FAAmC;AAC7C,WAAW,mBAAO,CAAC,sDAAO;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACXY;;AAEZ,WAAW,mBAAO,CAAC,gCAAa;AAChC,UAAU,8FAAoC;AAC9C,eAAe,mBAAO,CAAC,8DAAU;;AAEjC;AACA;AACA,kCAAkC,8BAA8B;AAChE;AACA;;AAEA;AACA;AACA,0CAA0C,8BAA8B;AACxE;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACrBY;;AAEZ,WAAW,mBAAO,CAAC,gCAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC7SY;;AAEZ,WAAW,mBAAO,CAAC,sDAAO;AAC1B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA,gCAAgC,cAAc;AAC9C,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sCAAsC,mBAAmB;AACzD;;AAEA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD,qCAAqC,cAAc;AACnD;AACA;AACA;AACA,IAAI;AACJ,wCAAwC;AACxC;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA,+DAA+D,KAAK,oBAAoB,IAAI;AAC5F;AACA;AACA,2DAA2D,KAAK,wBAAwB,IAAI;AAC5F;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC,GAAG;AACH;;AAEA;AACA,UAAU,oBAAoB;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yDAAyD,KAAK,oBAAoB,IAAI;AACtF;AACA;AACA,qDAAqD,KAAK,wBAAwB,IAAI;AACtF;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU,GAAG,IAAI,kCAAkC,KAAK;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzJY;;AAEZ,WAAW,mBAAO,CAAC,gCAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA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","sources":["webpack://x-manager-server/./src/Database.js","webpack://x-manager-server/./src/ExpressApp.js","webpack://x-manager-server/./src/Result.js","webpack://x-manager-server/./src/UserService.js","webpack://x-manager-server/./node_modules/fs-extra/lib/copy/copy-sync.js","webpack://x-manager-server/./node_modules/fs-extra/lib/copy/copy.js","webpack://x-manager-server/./node_modules/fs-extra/lib/copy/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/empty/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/ensure/file.js","webpack://x-manager-server/./node_modules/fs-extra/lib/ensure/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/ensure/link.js","webpack://x-manager-server/./node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack://x-manager-server/./node_modules/fs-extra/lib/ensure/symlink-type.js","webpack://x-manager-server/./node_modules/fs-extra/lib/ensure/symlink.js","webpack://x-manager-server/./node_modules/fs-extra/lib/fs/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/json/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/json/jsonfile.js","webpack://x-manager-server/./node_modules/fs-extra/lib/json/output-json-sync.js","webpack://x-manager-server/./node_modules/fs-extra/lib/json/output-json.js","webpack://x-manager-server/./node_modules/fs-extra/lib/mkdirs/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/mkdirs/make-dir.js","webpack://x-manager-server/./node_modules/fs-extra/lib/mkdirs/utils.js","webpack://x-manager-server/./node_modules/fs-extra/lib/move/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/move/move-sync.js","webpack://x-manager-server/./node_modules/fs-extra/lib/move/move.js","webpack://x-manager-server/./node_modules/fs-extra/lib/output-file/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/path-exists/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/remove/index.js","webpack://x-manager-server/./node_modules/fs-extra/lib/remove/rimraf.js","webpack://x-manager-server/./node_modules/fs-extra/lib/util/stat.js","webpack://x-manager-server/./node_modules/fs-extra/lib/util/utimes.js","webpack://x-manager-server/./node_modules/glob-promise/lib/index.js","webpack://x-manager-server/./node_modules/jsonfile/index.js","webpack://x-manager-server/./node_modules/jsonfile/utils.js","webpack://x-manager-server/./node_modules/universalify/index.js","webpack://x-manager-server/external commonjs \"@webantic/nginx-config-parser\"","webpack://x-manager-server/external commonjs \"body-parser\"","webpack://x-manager-server/external commonjs \"cookie-parser\"","webpack://x-manager-server/external commonjs \"express\"","webpack://x-manager-server/external commonjs \"glob\"","webpack://x-manager-server/external commonjs \"graceful-fs\"","webpack://x-manager-server/external commonjs \"nedb-promises\"","webpack://x-manager-server/external commonjs \"util\"","webpack://x-manager-server/external node-commonjs \"assert\"","webpack://x-manager-server/external node-commonjs \"crypto\"","webpack://x-manager-server/external node-commonjs \"fs\"","webpack://x-manager-server/external node-commonjs \"path\"","webpack://x-manager-server/external node-commonjs \"process\"","webpack://x-manager-server/webpack/bootstrap","webpack://x-manager-server/webpack/runtime/compat get default export","webpack://x-manager-server/webpack/runtime/define property getters","webpack://x-manager-server/webpack/runtime/hasOwnProperty shorthand","webpack://x-manager-server/webpack/runtime/make namespace object","webpack://x-manager-server/./src/index.js"],"sourcesContent":["import nedb from \"nedb-promises\";\r\n\r\nclass Database {\r\n    /**@type {nedb} */\r\n    db;\r\n\r\n    /**\r\n     * 初始化文件数据库\r\n     * @param {string} filepath \r\n     */\r\n    constructor(filepath) {\r\n        this.db = nedb.create(filepath);\r\n    }\r\n\r\n    /**\r\n     * 创建mapper\r\n     * @param {string} table 表名\r\n     */\r\n    createMapper(table) {\r\n        return new Mapper(this, table);\r\n    }\r\n\r\n    /**\r\n     * 加载\r\n     * @returns\r\n     */\r\n    async load() {\r\n        return await this.db.load();\r\n    }\r\n\r\n    /**\r\n     * 使用id获取一个对象\r\n     * @param {string} table \r\n     * @param {string} id \r\n     * @returns \r\n     */\r\n    async getById(table, id) {\r\n        let result = await this.db.findOne({ table, id });\r\n        if (!result)\r\n            return result;\r\n        delete result.table;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 获取一个对象\r\n     * @param {string} table \r\n     * @param {object} [query] \r\n     * @param {object} [sortQuery] \r\n     * @returns \r\n     */\r\n    async get(table, query, sortQuery) {\r\n        if (typeof query !== \"object\")\r\n            query = {};\r\n        query.table = table;\r\n        let pending = this.db.findOne(query);\r\n        if (typeof sortQuery === \"object\")\r\n            pending.sort(sortQuery);\r\n\r\n        let result = await pending;\r\n        if (!result)\r\n            return result;\r\n        delete result.table;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 获取所有符合条件的数据\r\n     * @param {string} table \r\n     * @param {object} [query] \r\n     * @param {object} [sortQuery] \r\n     * @returns \r\n     */\r\n    async list(table, query, sortQuery) {\r\n        if (typeof query !== \"object\")\r\n            query = {};\r\n        query.table = table;\r\n        let pended = this.db.find(query);\r\n        if (typeof sortQuery === \"object\")\r\n            pended = pended.sort(sortQuery);\r\n        let results = await pending;\r\n        if (!results)\r\n            return results;\r\n        results.map(function (result) {\r\n            delete result.table;\r\n        });\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * 插入数据\r\n     * @param {string} table \r\n     * @param {object} data \r\n     * @returns \r\n     */\r\n    async insert(table, data) {\r\n        if (typeof data !== \"object\")\r\n            throw \"参数错误： data不能为空\";\r\n        data.table = table;\r\n        return await this.db.insert(data);\r\n    }\r\n\r\n    /**\r\n     * 更新数据\r\n     * @param {string} table \r\n     * @param {object} query \r\n     * @param {object} updater \r\n     */\r\n    async update(table, query, updater) {\r\n        if (typeof query !== \"object\")\r\n            throw \"query cannot be \" + query;\r\n        if (typeof updater !== \"object\")\r\n            throw \"updater cannot be \" + query;\r\n        query.table = table;\r\n        return await this.db.update(query, updater);\r\n    }\r\n\r\n    /**\r\n     * 删除数据\r\n     * @param {string} table \r\n     * @param {object} query \r\n     */\r\n    async delete(table, query) {\r\n        if (typeof query !== \"object\")\r\n            query = {};\r\n        query.table = table;\r\n        return await this.db.remove(query, { multi: true });\r\n    }\r\n\r\n    /**\r\n     * 获取行数\r\n     * @param {string} table \r\n     * @param {object} [query] \r\n     */\r\n    async count(table, query) {\r\n        if (typeof query !== \"object\")\r\n            query = {};\r\n        query.table = table;\r\n        return await this.db.count(query);\r\n    }\r\n}\r\n\r\nclass Mapper {\r\n    /**@type {Database} */\r\n    db;\r\n\r\n    /**@type {string} */\r\n    table;\r\n\r\n    /**\r\n     * 构造Mapper\r\n     * @param {Database} db \r\n     * @param {string} table \r\n     */\r\n    constructor(db, table) {\r\n        this.db = db;\r\n        this.table = table;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 使用id获取一个对象\r\n     * @param {string} id \r\n     * @returns \r\n     */\r\n    async getById(id) {\r\n        return await this.db.getById(this.table, { id });\r\n    }\r\n\r\n    /**\r\n     * 获取一个对象\r\n     * @param {object} [query] \r\n     * @param {object} [sortQuery] \r\n     * @returns \r\n     */\r\n    async get(query, sortQuery) {\r\n        return await this.db.get(this.table, query, sortQuery);\r\n    }\r\n\r\n    /**\r\n     * 获取所有符合条件的数据\r\n     * @param {object} [query] \r\n     * @param {object} [sortQuery] \r\n     * @returns \r\n     */\r\n    async list(query, sortQuery) {\r\n        return await this.db.list(this.table, query, sortQuery);\r\n    }\r\n\r\n    /**\r\n     * 插入数据\r\n     * @param {object} data \r\n     * @returns \r\n     */\r\n    async insert(data) {\r\n        return await this.db.insert(this.table, data);\r\n    }\r\n\r\n    /**\r\n     * 更新数据\r\n     * @param {object} query \r\n     * @param {object} updater \r\n     */\r\n    async update(query, updater) {\r\n        return await this.db.update(this.table, query, updater);\r\n    }\r\n\r\n    /**\r\n     * 删除数据\r\n     * @param {object} query \r\n     */\r\n    async delete(query) {\r\n        return await this.db.delete(this.table, query);\r\n    }\r\n\r\n    /**\r\n     * 获取行数\r\n     * @param {object} [query] \r\n     */\r\n    async count(query) {\r\n        return await this.db.count(this.table, query);\r\n    }\r\n}\r\n\r\nDatabase.Mapper = Mapper;\r\n\r\nexport default Database;","import express, { Express, Request, Response } from \"express\";\r\nimport Result from \"./Result\";\r\nimport process from \"process\";\r\nimport cookieParser from \"cookie-parser\";\r\nimport bodyParser from \"body-parser\";\r\n\r\nfunction makeSessoinId() {\r\n    let buf = Buffer.allocUnsafe(16);\r\n    buf.writeUInt32LE(process.pid % 4294967295, 0);\r\n    buf.writeDoubleLE(new Date().getTime(), 4);\r\n    buf.writeUInt32LE(parseInt(Math.random() * 4294967295), 12)\r\n    return buf.toString(\"hex\");\r\n}\r\n\r\n/**\r\n * @typedef {(this: ExpressApp, param: {request: Request, response: Response, params: any, body: any, session: {} })=>Result | void} HttpHandler\r\n */\r\n\r\n/**\r\n * \r\n * @this {ExpressApp}\r\n * @param {HttpHandler} cb\r\n * @param {Request} request\r\n * @param {Response} response\r\n */\r\nasync function callback(cb, request, response) {\r\n    let sessionId = request.cookies ? request.cookies.JSESSIONID : undefined;\r\n    let session;\r\n    let now = new Date().getTime();\r\n    if (sessionId) {\r\n        session = this.sessions[sessionId];\r\n        if (session) {\r\n            if (parseInt((now - session.lastAccessTime) / 1000) >= this.maxInactiveInterval) {\r\n                delete this.sessions[sessionId];\r\n                session = undefined;\r\n            }\r\n            else\r\n                session.lastAccessTime = new Date().getTime();\r\n        }\r\n    }\r\n    if (!session) {\r\n        sessionId = makeSessoinId();\r\n        session = this.sessions[sessionId] = {\r\n            id: sessionId,\r\n            lastAccessTime: now,\r\n            createdTime: now\r\n        };\r\n        response.cookie(\"JSESSIONID\", sessionId);\r\n    }\r\n\r\n    let result;\r\n    try {\r\n        ExpressApp.session = session;\r\n        ExpressApp.request = request;\r\n        ExpressApp.response = response;\r\n\r\n        result = cb({\r\n            request,\r\n            response,\r\n            session,\r\n            params: request.params ? request.params : {},\r\n            body: request.body ? request.body : {},\r\n            headers: request.headers\r\n        });\r\n        ExpressApp.session = null;\r\n        ExpressApp.request = null;\r\n        ExpressApp.response = null;\r\n        if (result instanceof Promise)\r\n            result = await result;\r\n    } catch (err) {\r\n        if (err instanceof Result)\r\n            result = err;\r\n        else\r\n            result = new Result({ httpCode: 500, message: \"未知错误\" });\r\n    }\r\n\r\n    if (result) {\r\n        if (result.stream) {\r\n            response.status(200);\r\n            result.stream.pipe(response);\r\n        }\r\n        else if (result.httpCode)\r\n            response.status(result.httpCode).send(result.message);\r\n        else\r\n            response.status(200).send(JSON.stringify(result));\r\n    }\r\n    else\r\n        response.sendStatus(200);\r\n}\r\n\r\nclass ExpressApp {\r\n    /**@type {Express} */\r\n    app;\r\n\r\n    /**@type {Object} */\r\n    sessions = {};\r\n\r\n    /**@type {number} */\r\n    maxInactiveInterval = 30 * 1000;\r\n\r\n    constructor() {\r\n        this.app = express();\r\n        this.app.use(cookieParser());\r\n        this.app.use(bodyParser.urlencoded({ extended: false }));\r\n        this.app.use(bodyParser.json());\r\n    }\r\n\r\n    /**\r\n     * get请求\r\n     * @param {string} url \r\n     * @param {HttpHandler} cb \r\n     */\r\n    get(url, cb) {\r\n        this.app.get(url, callback.bind(this, cb));\r\n    }\r\n\r\n    /**\r\n     * post请求\r\n     * @param {string} url \r\n     * @param {HttpHandler} cb \r\n     */\r\n    post(url, cb) {\r\n        this.app.post(url, callback.bind(this, cb));\r\n    }\r\n\r\n    /**\r\n     * put请求\r\n     * @param {string} url \r\n     * @param {HttpHandler} cb \r\n     */\r\n    put(url, cb) {\r\n        this.app.put(url, callback.bind(this, cb));\r\n    }\r\n\r\n    /**\r\n     * delete请求\r\n     * @param {string} url \r\n     * @param {HttpHandler} cb \r\n     */\r\n    delete(url, cb) {\r\n        this.app.delete(url, callback.bind(this, cb));\r\n    }\r\n\r\n    /**\r\n     * options请求\r\n     * @param {string} url \r\n     * @param {HttpHandler} cb \r\n     */\r\n    options(url, cb) {\r\n        this.app.options(url, callback.bind(this, cb));\r\n    }\r\n\r\n    /**\r\n     * 开始监听\r\n     * @param {number} [port] 监听端口\r\n     */\r\n    async listen(port) {\r\n        return new Promise((resolve) => {\r\n            this.app.listen(port, () => {\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**@type {Object} */\r\nExpressApp.session = null;\r\n/**@type {Request} */\r\nExpressApp.request = null;\r\n/**@type {Response} */\r\nExpressApp.response = null;\r\n\r\nexport default ExpressApp;","\r\n\r\nclass Result {\r\n    /**\r\n     * 构造结果\r\n     * @param {{code?: number, httpCode?: number, stream?: NodeJS.ReadableStream, message?: string, result?: any}} options \r\n     */\r\n    constructor(options) {\r\n        if (typeof options.httpCode !== \"undefined\") {\r\n            this.httpCode = options.httpCode;\r\n            this.message = options.message;\r\n        }\r\n        else if (!options.code || options.code == 0) {\r\n            this.ok = true;\r\n            this.code = 0;\r\n            this.result = options.result;\r\n            this.stream = options.stream;\r\n        }\r\n        else {\r\n            this.ok = false;\r\n            this.code = options.code;\r\n            this.message = options.message;\r\n        }\r\n    }\r\n\r\n    toJson() {\r\n        return JSON.stringify(this);\r\n    }\r\n}\r\n\r\n/**\r\n * 成功回调\r\n * @param {any} result \r\n * @returns \r\n */\r\nResult.ok = function (result) {\r\n    return new Result({ result });\r\n};\r\n\r\n/**\r\n * 失败回调\r\n * @param {number} [code] \r\n * @param {string} [message] \r\n */\r\nResult.fail = function (code, message) {\r\n    if (typeof code == \"number\")\r\n        return new Result({ code, message });\r\n    else if (typeof code === \"string\")\r\n        return new Result({ code: -1000, message: code });\r\n    return new Result({ code: -1000, message: \"未知错误\" });\r\n}\r\n\r\n/**\r\n * 返回403错误\r\n * @param {string} message \r\n * @returns \r\n */\r\nResult.forbid = function (message) {\r\n    return new Result({ httpCode: 403, message });\r\n}\r\nexport default Result;","import Database from \"./Database\";\r\nimport crypto from \"crypto\";\r\nimport ExpressApp from \"./ExpressApp\";\r\nimport Result from \"./Result\";\r\n\r\n\r\nfunction sha256(value) {\r\n    let digest = crypto.createHash(\"sha256\");\r\n    return digest.update(value).digest().toString(\"hex\");\r\n}\r\n\r\nfunction genSalt() {\r\n    let salt = \"\";\r\n    let hexs = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', '_', '~', '=', '+'];\r\n    for (let i = 0; i < 16; i++)\r\n        salt += hexs[parseInt(Math.random() * hexs.length)];\r\n    return salt;\r\n}\r\n\r\nclass UserService {\r\n    /**@type {Database.Mapper} */\r\n    db;\r\n\r\n    /**\r\n     * \r\n     * @param {Database} db \r\n     */\r\n    constructor(db) {\r\n        this.db = db.createMapper(\"user\");\r\n        (async () => {\r\n            let user = await this.db.get({ username: \"admin\" });\r\n            if (!user) {\r\n                user = { username: \"admin\" };\r\n                user.salt = genSalt();\r\n                user.password = sha256(\"admin\" + user.salt);\r\n                user.realname = \"管理员\";\r\n                user.status = 1;\r\n                await this.db.insert(user);\r\n            }\r\n        })();\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {{username: string, password: string, realname: string, phone?: string, sex?: number, email?: string}} user \r\n     */\r\n    async register(user) {\r\n        let session = ExpressApp.session;\r\n        if (!user.username || user.username.length > 16)\r\n            return Result.fail(\"username参数格式错误\");\r\n        if (!user.password || user.password.length > 16)\r\n            return Result.fail(\"password参数格式错误\");\r\n        if (!user.realname || user.realname.length > 16)\r\n            return Result.fail(\"realname参数格式错误\");\r\n        if (user.phone && !/^(\\+\\d\\d)?[1-9]\\d{10}$/g.test(user.phone))\r\n            return Result.fail(\"phone参数格式错误\");\r\n\r\n        let userDb = await this.db.get({ username: user.username })\r\n        if (userDb)\r\n            return Result.fail(\"用户名已存在\");\r\n        user.table = \"user\";\r\n        user.salt = genSalt();\r\n        user.password = sha256(user.password + user.salt);\r\n        user.status = 1;\r\n        await this.db.insert(user);\r\n        session.user = user;\r\n        return Result.ok();\r\n    }\r\n\r\n    /**\r\n     * 登录\r\n     * @param {string} username \r\n     * @param {string} password \r\n     * @param {string} salt \r\n     * @returns \r\n     */\r\n    async login(username, password) {\r\n        let session = ExpressApp.session;\r\n        if (session.user)\r\n            return Result.fail(\"用户已登录\");\r\n        let user = await this.db.get({ username })\r\n        if (!user)\r\n            return Result.fail(\"用户不存在\");\r\n        if (user.status === 0)\r\n            return Result.fail(\"该用户已被禁用\");\r\n\r\n        let encodedPwd = sha256(password + user.salt);\r\n        if (encodedPwd != user.password)\r\n            return Result.fail(\"密码错误\");\r\n\r\n        user.id = user._id;\r\n        delete user.password;\r\n        delete user.salt;\r\n        delete user._id;\r\n\r\n        session.user = user;\r\n        return Result.ok(user)\r\n    }\r\n\r\n    /**\r\n     * 启用用户\r\n     * @param {{username: string, password?: string, realname?: string, phone?: string, sex?: number, email?: string, status?: number}} user \r\n     * @returns \r\n     */\r\n    async update(user) {\r\n        let session = ExpressApp.session;\r\n        if (!session.user || (session.user.username != \"admin\" && session.user.username != user.username))\r\n            return Result.forbid(\"没有权限\");\r\n\r\n        let query = { username: user.username };\r\n        let updater = {};\r\n        if (user.password) {\r\n            let userDB = await this.db.get({ username: user.username })\r\n            if (!userDB)\r\n                return Result.fail(\"该用户不存在\");\r\n            updater.password = sha256(user.password + userDB.salt);\r\n        }\r\n        if (user.realname)\r\n            updater.realname = user.realname;\r\n        if (user.phone)\r\n            updater.phone = user.phone;\r\n        if (user.sex)\r\n            updater.sex = user.sex;\r\n        if (user.email)\r\n            updater.email = user.email;\r\n        if (typeof user.status !== \"undefined\")\r\n            updater.status = user.status;\r\n        let num = await this.db.update(query, { $set: updater });\r\n        if (num == 0)\r\n            return Result.fail(\"用户不存在\");\r\n    }\r\n}\r\n\r\nexport default UserService;","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0002'\n    )\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirs = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimesMillis = require('../util/utimes').utimesMillis\nconst stat = require('../util/stat')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  stat.checkPaths(src, dest, 'copy', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return getStats(destStat, src, dest, opts, cb)\n    mkdirs(destParent, err => {\n      if (err) return cb(err)\n      return getStats(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`))\n    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`))\n    return cb(new Error(`Unknown file: ${src}`))\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  fs.copyFile(src, dest, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)\n    return setDestMode(dest, srcStat.mode, cb)\n  })\n}\n\nfunction handleTimestampsAndMode (srcMode, src, dest, cb) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    return makeFileWritable(dest, srcMode, err => {\n      if (err) return cb(err)\n      return setDestTimestampsAndMode(srcMode, src, dest, cb)\n    })\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest, cb)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode, cb) {\n  return setDestMode(dest, srcMode | 0o200, cb)\n}\n\nfunction setDestTimestampsAndMode (srcMode, src, dest, cb) {\n  setDestTimestamps(src, dest, err => {\n    if (err) return cb(err)\n    return setDestMode(dest, srcMode, cb)\n  })\n}\n\nfunction setDestMode (dest, srcMode, cb) {\n  return fs.chmod(dest, srcMode, cb)\n}\n\nfunction setDestTimestamps (src, dest, cb) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  fs.stat(src, (err, updatedSrcStat) => {\n    if (err) return cb(err)\n    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return setDestMode(dest, srcMode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy')),\n  copySync: require('./copy-sync')\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(async function emptyDir (dir) {\n  let items\n  try {\n    items = await fs.readdir(dir)\n  } catch {\n    return mkdir.mkdirs(dir)\n  }\n\n  return Promise.all(items.map(item => remove.remove(path.join(dir, item))))\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    fs.stat(dir, (err, stats) => {\n      if (err) {\n        // if the directory doesn't exist, make it\n        if (err.code === 'ENOENT') {\n          return mkdir.mkdirs(dir, err => {\n            if (err) return callback(err)\n            makeFile()\n          })\n        }\n        return callback(err)\n      }\n\n      if (stats.isDirectory()) makeFile()\n      else {\n        // parent is not a directory\n        // This is just to cause an internal ENOTDIR error to be thrown\n        fs.readdir(dir, err => {\n          if (err) return callback(err)\n        })\n      }\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      // parent is not a directory\n      // This is just to cause an internal ENOTDIR error to be thrown\n      fs.readdirSync(dir)\n    }\n  } catch (err) {\n    // If the stat call above failed because the directory doesn't exist, create it\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)\n    else throw err\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst { createFile, createFileSync } = require('./file')\nconst { createLink, createLinkSync } = require('./link')\nconst { createSymlink, createSymlinkSync } = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile,\n  createFileSync,\n  ensureFile: createFile,\n  ensureFileSync: createFileSync,\n  // link\n  createLink,\n  createLinkSync,\n  ensureLink: createLink,\n  ensureLinkSync: createLinkSync,\n  // symlink\n  createSymlink,\n  createSymlinkSync,\n  ensureSymlink: createSymlink,\n  ensureSymlinkSync: createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\nconst { areIdentical } = require('../util/stat')\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  fs.lstat(dstpath, (_, dstStat) => {\n    fs.lstat(srcpath, (err, srcStat) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n      if (dstStat && areIdentical(srcStat, dstStat)) return callback(null)\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  let dstStat\n  try {\n    dstStat = fs.lstatSync(dstpath)\n  } catch {}\n\n  try {\n    const srcStat = fs.lstatSync(srcpath)\n    if (dstStat && areIdentical(srcStat, dstStat)) return\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        toCwd: srcpath,\n        toDst: srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          toCwd: relativeToDst,\n          toDst: srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        toCwd: relativeToDst,\n        toDst: srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        toCwd: srcpath,\n        toDst: path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('../fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nconst { areIdentical } = require('../util/stat')\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  fs.lstat(dstpath, (err, stats) => {\n    if (!err && stats.isSymbolicLink()) {\n      Promise.all([\n        fs.stat(srcpath),\n        fs.stat(dstpath)\n      ]).then(([srcStat, dstStat]) => {\n        if (areIdentical(srcStat, dstStat)) return callback(null)\n        _createSymlink(srcpath, dstpath, type, callback)\n      })\n    } else _createSymlink(srcpath, dstpath, type, callback)\n  })\n}\n\nfunction _createSymlink (srcpath, dstpath, type, callback) {\n  symlinkPaths(srcpath, dstpath, (err, relative) => {\n    if (err) return callback(err)\n    srcpath = relative.toDst\n    symlinkType(relative.toCwd, type, (err, type) => {\n      if (err) return callback(err)\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n        mkdirs(dir, err => {\n          if (err) return callback(err)\n          fs.symlink(srcpath, dstpath, type, callback)\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  let stats\n  try {\n    stats = fs.lstatSync(dstpath)\n  } catch {}\n  if (stats && stats.isSymbolicLink()) {\n    const srcStat = fs.statSync(srcpath)\n    const dstStat = fs.statSync(dstpath)\n    if (areIdentical(srcStat, dstStat)) return\n  }\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchmod',\n  'lchown',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rm',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.opendir was added in Node.js v12.12.0\n  // fs.rm was added in Node.js v14.14.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export cloned fs:\nObject.assign(exports, fs)\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.writev only available in Node v12.9.0+\nif (typeof fs.writev === 'function') {\n  // Function signature is\n  // s.writev(fd, buffers[, position], callback)\n  // We need to handle the optional arg, so we use ...args\n  exports.writev = function (fd, buffers, ...args) {\n    if (typeof args[args.length - 1] === 'function') {\n      return fs.writev(fd, buffers, ...args)\n    }\n\n    return new Promise((resolve, reject) => {\n      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n        if (err) return reject(err)\n        resolve({ bytesWritten, buffers })\n      })\n    })\n  }\n}\n\n// fs.realpath.native sometimes not available if fs is monkey-patched\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n} else {\n  process.emitWarning(\n    'fs.realpath.native is not a function. Is fs being monkey-patched?',\n    'Warning', 'fs-extra-WARN0003'\n  )\n}\n","'use strict'\n\nmodule.exports = {\n  // Export promiseified graceful-fs:\n  ...require('./fs'),\n  // Export extra methods:\n  ...require('./copy'),\n  ...require('./empty'),\n  ...require('./ensure'),\n  ...require('./json'),\n  ...require('./mkdirs'),\n  ...require('./move'),\n  ...require('./output-file'),\n  ...require('./path-exists'),\n  ...require('./remove')\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync\n}\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFileSync } = require('../output-file')\n\nfunction outputJsonSync (file, data, options) {\n  const str = stringify(data, options)\n\n  outputFileSync(file, str, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFile } = require('../output-file')\n\nasync function outputJson (file, data, options = {}) {\n  const str = stringify(data, options)\n\n  await outputFile(file, str, options)\n}\n\nmodule.exports = outputJson\n","'use strict'\nconst u = require('universalify').fromPromise\nconst { makeDir: _makeDir, makeDirSync } = require('./make-dir')\nconst makeDir = u(_makeDir)\n\nmodule.exports = {\n  mkdirs: makeDir,\n  mkdirsSync: makeDirSync,\n  // alias\n  mkdirp: makeDir,\n  mkdirpSync: makeDirSync,\n  ensureDir: makeDir,\n  ensureDirSync: makeDirSync\n}\n","'use strict'\nconst fs = require('../fs')\nconst { checkPath } = require('./utils')\n\nconst getMode = options => {\n  const defaults = { mode: 0o777 }\n  if (typeof options === 'number') return options\n  return ({ ...defaults, ...options }).mode\n}\n\nmodule.exports.makeDir = async (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdir(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n\nmodule.exports.makeDirSync = (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdirSync(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n","// Adapted from https://github.com/sindresorhus/make-dir\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict'\nconst path = require('path')\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nmodule.exports.checkPath = function checkPath (pth) {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''))\n\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`)\n      error.code = 'EINVAL'\n      throw error\n    }\n  }\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  move: u(require('./move')),\n  moveSync: require('./move-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, 'move', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite, isChangingCase)\n}\n\nfunction isParentRoot (dest) {\n  const parent = path.dirname(dest)\n  const parsedPath = path.parse(parent)\n  return parsedPath.root === parent\n}\n\nfunction doRename (src, dest, overwrite, isChangingCase) {\n  if (isChangingCase) return rename(src, dest, overwrite)\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\nconst stat = require('../util/stat')\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  opts = opts || {}\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, isChangingCase = false } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, isChangingCase, cb)\n      })\n    })\n  })\n}\n\nfunction isParentRoot (dest) {\n  const parent = path.dirname(dest)\n  const parsedPath = path.parse(parent)\n  return parsedPath.root === parent\n}\n\nfunction doRename (src, dest, overwrite, isChangingCase, cb) {\n  if (isChangingCase) return rename(src, dest, overwrite, cb)\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nfunction remove (path, callback) {\n  // Node 14.14.0+\n  if (fs.rm) return fs.rm(path, { recursive: true, force: true }, callback)\n  rimraf(path, callback)\n}\n\nfunction removeSync (path) {\n  // Node 14.14.0+\n  if (fs.rmSync) return fs.rmSync(path, { recursive: true, force: true })\n  rimraf.sync(path)\n}\n\nmodule.exports = {\n  remove: u(remove),\n  removeSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch {}\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src)\n        const destBaseName = path.basename(dest)\n        if (funcName === 'move' &&\n          srcBaseName !== destBaseName &&\n          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, { srcStat, destStat, isChangingCase: true })\n        }\n        return cb(new Error('Source and destination must not be the same.'))\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  fs.stat(destParent, { bigint: true }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  })\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  utimesMillis,\n  utimesMillisSync\n}\n","const glob = require('glob')\n\nconst promise = function (pattern, options) {\n  return new Promise((resolve, reject) => {\n    glob(pattern, options, (err, files) => err === null ? resolve(files) : reject(err))\n  })\n}\n\n// default\nmodule.exports = promise\n\n// utility exports\nmodule.exports.glob = glob\nmodule.exports.Glob = glob.Glob\nmodule.exports.hasMagic = glob.hasMagic\nmodule.exports.promise = promise\nmodule.exports.sync = glob.sync\n","let _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\nconst universalify = require('universalify')\nconst { stringify, stripBom } = require('./utils')\n\nasync function _readFile (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  let data = await universalify.fromCallback(fs.readFile)(file, options)\n\n  data = stripBom(data)\n\n  let obj\n  try {\n    obj = JSON.parse(data, options ? options.reviver : null)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n\n  return obj\n}\n\nconst readFile = universalify.fromPromise(_readFile)\n\nfunction readFileSync (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  try {\n    let content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nasync function _writeFile (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n\n  await universalify.fromCallback(fs.writeFile)(file, str, options)\n}\n\nconst writeFile = universalify.fromPromise(_writeFile)\n\nfunction writeFileSync (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nconst jsonfile = {\n  readFile,\n  readFileSync,\n  writeFile,\n  writeFileSync\n}\n\nmodule.exports = jsonfile\n","function stringify (obj, { EOL = '\\n', finalEOL = true, replacer = null, spaces } = {}) {\n  const EOF = finalEOL ? EOL : ''\n  const str = JSON.stringify(obj, replacer, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOF\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  return content.replace(/^\\uFEFF/, '')\n}\n\nmodule.exports = { stringify, stripBom }\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.call(\n          this,\n          ...args,\n          (err, res) => (err != null) ? reject(err) : resolve(res)\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","module.exports = require(\"@webantic/nginx-config-parser\");","module.exports = require(\"body-parser\");","module.exports = require(\"cookie-parser\");","module.exports = require(\"express\");","module.exports = require(\"glob\");","module.exports = require(\"graceful-fs\");","module.exports = require(\"nedb-promises\");","module.exports = require(\"util\");","module.exports = require(\"assert\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"process\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Database from \"./Database\";\r\nimport ExpressApp from \"./ExpressApp\"\r\nimport UserService from \"./UserService\"\r\nimport ConfigParser from \"@webantic/nginx-config-parser\";\r\n\r\nimport fs from \"fs-extra\";\r\nimport path from \"path\";\r\nimport glob from \"glob-promise\"\r\n\r\nasync function loadFunction(filepath) {\r\n    let parser = new ConfigParser();\r\n    let dir = path.dirname(filepath);\r\n    let content = await fs.readFile(filepath, \"utf-8\");\r\n    let configs = {};\r\n    let rootConfig = parser.parse(content);\r\n    configs.root = rootConfig;\r\n\r\n    let includes = rootConfig.http.include;\r\n    for (let i = 0; i < includes.length; ++i) {\r\n        let includePath = path.resolve(dir, includes[i]);\r\n        let stat;\r\n        if (fs.existsSync(includePath) && (stat = await fs.stat(includePath)).isFile()) {\r\n            content = await fs.readFile(includePath, \"utf-8\");\r\n            configs[includes[i]] = parser.parse(content);\r\n        }\r\n        else {\r\n            let files = await glob.promise(includePath);\r\n            for (let j = 0; j < files.length; j++) {\r\n                const file = files[j];\r\n                content = await fs.readFile(file);\r\n                configs[includes[i]] = parser.parse(content);\r\n            }\r\n        }\r\n    }\r\n    return configs;\r\n}\r\n\r\n(async function () {\r\n\r\n    let configs = await loadFunction(\"D:/lkq/tools/vps-docker/nginx/nginx/nginx.conf\");\r\n    console.log(configs);\r\n\r\n    let db = new Database(\"D:/upload/test.db\");\r\n    await db.load();\r\n\r\n    const app = new ExpressApp();\r\n    let userService = new UserService(db);\r\n    app.post(\"/register\", function ({ request, response, params, body }) {\r\n        return userService.register(body);\r\n    });\r\n\r\n    app.post(\"/login\", function ({ body }) {\r\n        return userService.login(body.username, body.password);\r\n    });\r\n\r\n    app.post(\"/user/update\", function ({ body }) {\r\n        return userService.update(body);\r\n    });\r\n\r\n    await app.listen(80);\r\n})();"],"names":["nedb","Database","db","constructor","filepath","create","createMapper","table","Mapper","load","getById","id","result","findOne","get","query","sortQuery","pending","sort","list","pended","find","results","map","insert","data","update","updater","delete","remove","multi","count","express","Express","Request","Response","Result","process","cookieParser","bodyParser","makeSessoinId","buf","Buffer","allocUnsafe","writeUInt32LE","pid","writeDoubleLE","Date","getTime","parseInt","Math","random","toString","callback","cb","request","response","sessionId","cookies","JSESSIONID","undefined","session","now","sessions","lastAccessTime","maxInactiveInterval","createdTime","cookie","ExpressApp","params","body","headers","Promise","err","httpCode","message","stream","status","pipe","send","JSON","stringify","sendStatus","app","use","urlencoded","extended","json","url","bind","post","put","options","listen","port","resolve","code","ok","toJson","fail","forbid","crypto","sha256","value","digest","createHash","genSalt","salt","hexs","i","length","UserService","user","username","password","realname","register","phone","test","userDb","login","encodedPwd","_id","userDB","sex","email","num","$set","ConfigParser","fs","path","glob","loadFunction","parser","dir","dirname","content","readFile","configs","rootConfig","parse","root","includes","http","include","includePath","stat","existsSync","isFile","files","promise","j","file","console","log","userService"],"sourceRoot":""}